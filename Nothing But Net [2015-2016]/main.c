#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  ultraIntake,    sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  ultraLift,      sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  ultraFront,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lift,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           pewL2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           pewL1,         tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           pewR1,         tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           pewR2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rollers,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)

//REMEMBER TO TRY PID

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

float roundsR;
float roundsL;
int increment = 1;
int updateFrequency = 5;
int lSpeed = 65;
int rSpeed= 65;
int x = 18;




#include "rps.h"
#include "userControl.h"
#include "partnerControl.h"
#include "autonomous.h"



#define PI 3.14159265358979323846
float radius_r = 22.86; //22.86 cm = 9 inches. This is the actual radius, not the variable declared in the function.
float radius_w = 5.08;

//idk what the name of the encoders are but this code should work if we get that and the radius.
void reset_encoders(){
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[frontLeft] = 0;
}


int encoder_degrees(int deg, int radius_robot, int radius_wheel){
	/*
	Takes a desired degree turn, the radius of the robot, the radius of the wheel
	and outputs the necessary degrees the encoder must turn.
	*/
	deg = deg*PI/180; // convert to radians 627.2
	return deg*radius_robot/radius_wheel;
}

void turn_degrees(int deg){
	int encoder_count = encoder_degrees(deg, radius_r, radius_w);
	int direction;
	deg = deg*180/PI;
	deg = deg*627.2/360.0;
	if(deg < 0){direction=-1;}
	if(deg > 0){direction=1;}

	while(nMotorEncoder[frontLeft] < deg && nMotorEncoder[backRight] < deg){
		motor[frontLeft] = motor[backLeft] = 127*direction;
		motor[frontRight] = motor[backRight] = -127*direction;
	}
}


void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{

	clearTimer(T1);
	clearTimer(T2);
	motor[pewL1] = motor[pewL2] = motor[pewR1] = motor[pewR2] = 65;
	wait1Msec(2000);
	//motor[frontLeft] = motor[backLeft] = 0; n

	startTask(autonomousLift);
	while(time1[T2]< 14000){
		RPS(x);
	}
	while(time1[T2]< 15000){
		increment=5;
		RPS(0);
	}
	motor[pewL1] = motor[pewL2] = motor[pewR1] = motor[pewR2] = 0;
	stopTask(autonomousLift);
	motor[lift] = motor[rollers] =  0;
	motor[frontRight] = motor[backRight] = motor[frontLeft] = motor[backLeft] = 0;

}

task usercontrol()
{
	increment = 2;

	startTask(move);
	startTask(autoIntake);
	startTask(varPower);
	//startTask(shootLift);
	StartTask(precision);

	while(true){
		RPS(x);
	}

}
